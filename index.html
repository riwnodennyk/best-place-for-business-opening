<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estimate Foot Traffic for Your Business | Free Map Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="styles.css" /> <!-- External CSS -->
</head>

<body>
    <div id="map"></div>
    <div id="loading">Calculating Foot Traffic in the Area...</div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script type="module">
        import { calculateArea } from './calculateArea.js';
        import { processBuildingData } from './businessDensity.js';

        let map;
        let buildingsLayer;
        let lastBounds = null;
        let currentRequestController = null;
        let loadingIndicator = document.getElementById('loading');

        function debounce(func, delay) {
            let timer;
            return function (...args) {
                clearTimeout(timer);
                timer = setTimeout(() => func.apply(this, args), delay);
            };
        }
        async function getUserLocation() {
            // return {lat: 50.177,lon:  30.318}; // Vasylkiv
            // return {lat: 50.079,lon:  29.909}; // Fastiv
            // return {lat: 50.398,lon: 30.619}; // osokorky
            // return {lat: 50.398, lon: 30.630}; // pozniaky
            // return {lat: 50.403,lon:  30.650}; // kharkivska
            // return {lat: 50.398,lon:  30.603}; // Slavutych
            // return {lat: 50.450,lon:  30.510}; // Zoloti vorota
            // return {lat: 50.440, lon: 30.520}; // Besarabka
            // return {lat: 52.383, lon: 4.632}; // Haarlem
            // return {lat: 51.508, lon: -0.128}; // london
           
            try {
                const response = await fetch("https://geolocation-db.com/json/");
                const data = await response.json();

                console.log("User Location: ", data.latitude, data.longitude);
                return { lat: data.latitude, lon: data.longitude };
            } catch (error) {
                console.warn("Could not fetch user location, using default:", error);
                return { lat: 1, lon: 1 }; // Default location
            }
        }

        async function initializeMap() {
            const userLocation = await getUserLocation();

            map = L.map('map', {
                center: [userLocation.lat, userLocation.lon],
                zoom: 16,
                minZoom: 15,
                maxZoom: 18
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);

            buildingsLayer = L.geoJSON(null).addTo(map);
            map.whenReady(() => fetchData(map.getBounds()));

            map.on("movestart", onMapMoveStart);
            map.on("moveend", onMapMoveEnd);
        }

        async function fetchData(bounds) {
            if (currentRequestController) {
                currentRequestController.abort(); // Cancel previous request
            }

            currentRequestController = new AbortController();
            const { signal } = currentRequestController;

            let bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
            console.log("Start fetching data for bbox:", bbox);

            const buildingsQuery = `
                [out:json][timeout:25];
                way["building"](${bbox});
                out body geom;
            `;

            const businessesQuery = `
                [out:json][timeout:25];
                (
                    node["shop"](${bbox});
                    node["office"](${bbox});
                    node["tourism"~"museum|attraction|gallery"](${bbox});
                    node["leisure"~"park|garden"](${bbox});
                    node[railway~"station|subway_entrance"](${bbox});
                    node[amenity~"restaurant|cafe|fast_food|pub|bar|marketplace|school|university|cinema|theatre|pharmacy|supermarket|mall|bank|bureau_de_change"](${bbox});                );
                out body;
            `;

            const buildingsUrl = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(buildingsQuery)}`;
            const businessesUrl = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(businessesQuery)}`;

            try {
                loadingIndicator.style.display = 'block';

                const [buildingsResponse, businessesResponse] = await Promise.all([
                    fetch(buildingsUrl, { signal }).then(res => res.json()),
                    fetch(businessesUrl, { signal }).then(res => res.json())
                ]);

                buildingsLayer.clearLayers();
                let foundBuildings = false;

                buildingsResponse.elements.forEach(building => {
                    if (building.type === "way" && building.geometry) {
                        const isBuildingProcessed = processBuildingData(building, businessesResponse, calculateArea, buildingsLayer);
                        if (isBuildingProcessed) foundBuildings = true;
                    }
                });

                if (!foundBuildings) {
                    console.warn("No buildings with sufficient business density found.");
                }
                loadingIndicator.style.display = 'none'; // Hide loading indicator once fetching completes
            } catch (error) {
                if (error.name !== "AbortError") {
                    console.error("Error fetching data:", error);
                } else {
                    console.error("AbortError");
                }
            } finally {
            }
        }

        const debouncedFetchData = debounce(fetchData, 500);

        function onMapMoveStart() {
            loadingIndicator.style.display = 'block';
            if (currentRequestController) {
                currentRequestController.abort();
            }
        }

        function onMapMoveEnd() {
            const bounds = map.getBounds();
            const currentBoundsString = bounds.toBBoxString();

            if (lastBounds !== currentBoundsString) {
                lastBounds = currentBoundsString;
                debouncedFetchData(bounds);
            }
        }

        initializeMap(); // Start the map initialization
    </script>
</body>

</html>