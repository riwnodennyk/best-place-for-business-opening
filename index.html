<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Density Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="styles.css" /> <!-- External CSS -->
</head>

<body>
    <div id="map"></div>
    <div id="loading">Loading data...</div> <!-- Loading indicator -->

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var mapConfig = {
            center: [50.398, 30.617],
            zoom: 15,
            maxZoom: 20,
            minZoom: 14,
        };

        var map = L.map('map', {
            center: mapConfig.center,
            zoom: mapConfig.zoom,
            minZoom: mapConfig.minZoom,
            maxZoom: mapConfig.maxZoom
        });

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        let buildingsLayer = L.geoJSON(null, {
            style: { color: 'yellow', weight: 1, fillOpacity: 0.6 }
        }).addTo(map);

        let lastBounds = null;
        let currentRequestController = null; // Used to cancel ongoing fetch
        let loadingIndicator = document.getElementById('loading');

        // Function to calculate the area of a polygon in square meters using the Shoelace Theorem
        function calculateArea(polygon) {
            let latLngs = polygon.getLatLngs()[0];
            let area = 0;

            for (let i = 0; i < latLngs.length; i++) {
                let j = (i + 1) % latLngs.length; // next point, wrapping around
                let lat1 = latLngs[i].lat;
                let lon1 = latLngs[i].lng;
                let lat2 = latLngs[j].lat;
                let lon2 = latLngs[j].lng;

                area += lon1 * lat2 - lon1 * lat1 - lon2 * lat1 + lon2 * lat2;
            }

            area = Math.abs(area) / 2;

            // Convert the area from degrees² to square meters (approximate conversion)
            // This is a rough approximation and may vary with latitudes and the Earth's curvature
            const latLngAreaFactor = 111319; // 1 degree of latitude is approx 111.319 km
            let areaInSquareMeters = area * latLngAreaFactor * latLngAreaFactor;

            return areaInSquareMeters;
        }


        async function fetchData(bounds) {
            if (currentRequestController) {
                currentRequestController.abort(); // Cancel previous request if it exists
            }

            currentRequestController = new AbortController(); // Create a new controller
            const { signal } = currentRequestController;

            let bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;

            let buildingsQuery = `
                [out:json][timeout:25];
                way["building"](${bbox});
                out body geom;
            `;
            let businessesQuery = `
                [out:json][timeout:25];
                (
                    node["shop"](${bbox});
                    node["office"](${bbox});
                    node["amenity"="restaurant"](${bbox});
                );
                out body;
            `;

            let buildingsUrl = "https://overpass-api.de/api/interpreter?data=" + encodeURIComponent(buildingsQuery);
            let businessesUrl = "https://overpass-api.de/api/interpreter?data=" + encodeURIComponent(businessesQuery);

            try {
                loadingIndicator.style.display = 'block'; // Show loading indicator

                let [buildingsResponse, businessesResponse] = await Promise.all([
                    fetch(buildingsUrl, { signal }).then(res => res.json()),
                    fetch(businessesUrl, { signal }).then(res => res.json())
                ]);

                buildingsLayer.clearLayers(); // Remove previous data

                let foundBuildings = false;

                buildingsResponse.elements.forEach(building => {
                    if (building.type === "way" && building.geometry) {
                        let coords = building.geometry.map(pt => [pt.lat, pt.lon]);
                        let polygon = L.polygon(coords);

                        // Calculate the area of the building in square meters
                        let buildingArea = calculateArea(polygon);

                        // Count businesses inside the building's bounds
                        let businessesInBuilding = businessesResponse.elements.filter(business => {
                            return polygon.getBounds().contains([business.lat, business.lon]);
                        }).length;

                        // Calculate business density (businesses per square meter)
                        let businessDensity = buildingArea > 0 ? businessesInBuilding / buildingArea : 0;

                        if (businessDensity >= 0.001) { // Set your own threshold for density here
                            polygon.bindPopup(`Businesses per m²: ${businessDensity.toFixed(4)}`);
                            buildingsLayer.addLayer(polygon);
                            foundBuildings = true;
                        }
                    }
                });

                if (!foundBuildings) {
                    console.warn("No buildings with sufficient business density found in this viewport.");
                }

            } catch (error) {
                if (error.name !== "AbortError") {
                    console.error("Error fetching data:", error);
                }
            } finally {
                loadingIndicator.style.display = 'none'; // Hide loading indicator
            }
        }

        function onMapMoveEnd() {
            let bounds = map.getBounds();
            let currentBoundsString = bounds.toBBoxString();

            if (lastBounds !== currentBoundsString) {
                lastBounds = currentBoundsString;
                fetchData(bounds);
            }
        }

        // Load data immediately on launch
        map.whenReady(() => {
            fetchData(map.getBounds());
        });

        map.on("moveend", onMapMoveEnd);
    </script>
</body>
</html>